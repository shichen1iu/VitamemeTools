"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Subscribe = void 0;
class Subscribe {
    constructor(sdk) {
        this.sdk = sdk;
        this.onPriceUpdated = (vars, sink) => __awaiter(this, void 0, void 0, function* () {
            return this.sdk.subscribe(`subscription OnPriceUpdated($address: String, $networkId: Int, $sourcePairAddress: String) {
  onPriceUpdated (address: $address, networkId: $networkId, sourcePairAddress: $sourcePairAddress) {
    address, confidence, networkId, poolAddress, priceUsd, timestamp
  }
}`, vars, sink);
        });
        this.onLatestPairUpdated = (vars, sink) => __awaiter(this, void 0, void 0, function* () {
            return this.sdk.subscribe(`subscription OnLatestPairUpdated($id: String, $networkId: Int) {
  onLatestPairUpdated (id: $id, networkId: $networkId) {
    address, exchangeHash, id, initialPriceUsd, liquidAt, liquidity, liquidityToken, networkId, newToken, nonLiquidityToken, oldToken, priceChange, priceUsd, token0 { address, currentPoolAmount, decimals, id, initialPoolAmount, name, networkId, pairId, poolVariation, symbol }, token1 { address, currentPoolAmount, decimals, id, initialPoolAmount, name, networkId, pairId, poolVariation, symbol }, transactionHash
  }
}`, vars, sink);
        });
        this.onTokenBarsUpdated = (vars, sink) => __awaiter(this, void 0, void 0, function* () {
            return this.sdk.subscribe(`subscription OnTokenBarsUpdated($statsType: TokenPairStatisticsType, $tokenId: String) {
  onTokenBarsUpdated (statsType: $statsType, tokenId: $tokenId) {
    aggregates { r1 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r1D { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r1S { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r5 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r5S { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r7D { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r15 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r15S { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r30 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r30S { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r60 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r240 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r720 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } } }, eventSortKey, networkId, pairAddress, pairId, quoteToken, statsType, timestamp, tokenAddress, tokenId
  }
}`, vars, sink);
        });
        this.onPairMetadataUpdated = (vars, sink) => __awaiter(this, void 0, void 0, function* () {
            return this.sdk.subscribe(`subscription OnPairMetadataUpdated($id: String, $quoteToken: QuoteToken, $statsType: TokenPairStatisticsType) {
  onPairMetadataUpdated (id: $id, quoteToken: $quoteToken, statsType: $statsType) {
    enhancedToken0 { address, cmcId, createBlockNumber, createTransactionHash, createdAt, creatorAddress, decimals, exchanges { address, color, exchangeVersion, iconUrl, id, name, networkId, tradeUrl }, freezable, id, info { address, circulatingSupply, cmcId, description, id, imageBannerUrl, imageLargeUrl, imageSmallUrl, imageThumbUrl, isScam, name, networkId, symbol, totalSupply }, isScam, mintable, name, networkId, socialLinks { bitcointalk, blog, coingecko, coinmarketcap, discord, email, facebook, github, instagram, linkedin, reddit, slack, telegram, twitch, twitter, website, wechat, whitepaper, youtube }, symbol }, enhancedToken1 { address, cmcId, createBlockNumber, createTransactionHash, createdAt, creatorAddress, decimals, exchanges { address, color, exchangeVersion, iconUrl, id, name, networkId, tradeUrl }, freezable, id, info { address, circulatingSupply, cmcId, description, id, imageBannerUrl, imageLargeUrl, imageSmallUrl, imageThumbUrl, isScam, name, networkId, symbol, totalSupply }, isScam, mintable, name, networkId, socialLinks { bitcointalk, blog, coingecko, coinmarketcap, discord, email, facebook, github, instagram, linkedin, reddit, slack, telegram, twitch, twitter, website, wechat, whitepaper, youtube }, symbol }, exchangeId, fee, highPrice1, highPrice1w, highPrice4, highPrice12, highPrice24, id, liquidity, liquidityToken, lowPrice1, lowPrice1w, lowPrice4, lowPrice12, lowPrice24, networkId, nonLiquidityToken, pairAddress, price, priceChange1, priceChange1w, priceChange4, priceChange5m, priceChange12, priceChange24, quoteToken, statsType, tickSpacing, token0 { address, decimals, labels { createdAt, subType, type }, name, networkId, pooled, price, symbol }, token1 { address, decimals, labels { createdAt, subType, type }, name, networkId, pooled, price, symbol }, volume1, volume1w, volume4, volume12, volume24
  }
}`, vars, sink);
        });
        this.onUnconfirmedBarsUpdated = (vars, sink) => __awaiter(this, void 0, void 0, function* () {
            return this.sdk.subscribe(`subscription OnUnconfirmedBarsUpdated($pairId: String, $quoteToken: QuoteToken) {
  onUnconfirmedBarsUpdated (pairId: $pairId, quoteToken: $quoteToken) {
    aggregates { r1 { c, h, l, o, t, v, volume }, r1S { c, h, l, o, t, v, volume }, r5 { c, h, l, o, t, v, volume }, r5S { c, h, l, o, t, v, volume }, r15 { c, h, l, o, t, v, volume }, r15S { c, h, l, o, t, v, volume } }, eventSortKey, networkId, pairAddress, pairId, quoteToken, quoteTokenAddress, timestamp
  }
}`, vars, sink);
        });
        this.onTokenLifecycleEventsCreated = (vars, sink) => __awaiter(this, void 0, void 0, function* () {
            return this.sdk.subscribe(`subscription OnTokenLifecycleEventsCreated($address: String, $networkId: Int) {
  onTokenLifecycleEventsCreated (address: $address, networkId: $networkId) {
    events { blockHash, blockNumber, data { ... on TokenBurnEventData { amount, circulatingSupply, totalSupply }, ... on TokenMintEventData { amount, circulatingSupply, totalSupply } }, eventType, id, logIndex, maker, networkId, timestamp, tokenAddress, transactionHash, transactionIndex }, id
  }
}`, vars, sink);
        });
        this.onTokenEventsCreated = (vars, sink) => __awaiter(this, void 0, void 0, function* () {
            return this.sdk.subscribe(`subscription OnTokenEventsCreated($input: OnTokenEventsCreatedInput!) {
  onTokenEventsCreated (input: $input) {
    events { address, baseTokenPrice, blockHash, blockNumber, data { ... on BurnEventData { amount0, amount0Shifted, amount1, amount1Shifted, tickLower, tickUpper, type }, ... on MintEventData { amount0, amount0Shifted, amount1, amount1Shifted, tickLower, tickUpper, type }, ... on PoolBalanceChangedEventData { amount0, amount0Shifted, amount1, amount1Shifted, liquidity0, liquidity1, protocolFeeAmount0, protocolFeeAmount1, sender, token0, token1, type }, ... on SwapEventData { amount0, amount0In, amount0Out, amount1, amount1In, amount1Out, amountNonLiquidityToken, priceBaseToken, priceBaseTokenTotal, priceUsd, priceUsdTotal, tick, type } }, eventDisplayType, eventType, id, labels { sandwich { label, sandwichType, token0DrainedAmount, token1DrainedAmount }, washtrade { label } }, liquidityToken, logIndex, maker, networkId, quoteToken, timestamp, token0Address, token0PoolValueUsd, token0SwapValueUsd, token0ValueBase, token1Address, token1PoolValueUsd, token1SwapValueUsd, token1ValueBase, transactionHash, transactionIndex }, id
  }
}`, vars, sink);
        });
        this.onNftAssetsCreated = (vars, sink) => __awaiter(this, void 0, void 0, function* () {
            return this.sdk.subscribe(`subscription OnNftAssetsCreated($address: String, $networkId: Int, $tokenId: String) {
  onNftAssetsCreated (address: $address, networkId: $networkId, tokenId: $tokenId) {
    address, attributes { class, css, displayType, maxValue, name, value, valueType }, description, id, media { image, processed, thumbLg, thumbSm }, name, networkId, originalImage, quantity, rawAssetData { animationUrl, externalUrl, imageData, imageUrl }, tokenId, uri
  }
}`, vars, sink);
        });
        this.onUnconfirmedEventsCreated = (vars, sink) => __awaiter(this, void 0, void 0, function* () {
            return this.sdk.subscribe(`subscription OnUnconfirmedEventsCreated($address: String, $id: String, $quoteToken: QuoteToken) {
  onUnconfirmedEventsCreated (address: $address, id: $id, quoteToken: $quoteToken) {
    address, events { address, blockHash, blockNumber, data { ... on UnconfirmedLiquidityChangeEventData { amount0, amount0Shifted, amount1, amount1Shifted, type }, ... on UnconfirmedSwapEventData { amountNonLiquidityToken, priceBaseToken, priceBaseTokenTotal, priceUsd, priceUsdTotal, type } }, eventDisplayType, eventType, id, logIndex, maker, networkId, quoteToken, supplementalIndex, timestamp, transactionHash, transactionIndex }, id, networkId, quoteToken
  }
}`, vars, sink);
        });
        this.onSimulateTokenContract = (vars, sink) => __awaiter(this, void 0, void 0, function* () {
            return this.sdk.subscribe(`subscription OnSimulateTokenContract($contractAddress: String, $networkId: Int!, $simulationId: String) {
  onSimulateTokenContract (contractAddress: $contractAddress, networkId: $networkId, simulationId: $simulationId) {
    analysisType, blockNumber, contractBalance { tokenContractEthBalance, tokenContractTokenBalance }, contractHashKey, creator { creatorAddress, creatorEthBalance, creatorTokenBalance }, deploy { deploySuccess, tokenMintedToDeployer }, errors { contractBalanceErrors { tokenContractEthBalanceError, tokenContractTokenBalanceError }, creatorErrors { creatorEthBalanceError, creatorTokenBalanceError }, deployErrors { deployError, tokenMintedToDeployerError }, liquidityErrors { addLiquidityError, lpTotalSupplyError, postLiquidityEnableTradingError, preLiquidityEnableTradingError }, ownerErrors { ownerAddressError, ownerEthBalanceError, ownerTokenBalanceError }, simulatorError, swapErrors { buyError, buyErrorEnum, sellError, sellErrorEnum }, tokenErrors { canRenounceOwnershipError, canTransferOwnershipError, decimalsError, tokenNameError, tokenSymbolError, totalSupplyError }, transferErrors { tokenContractApprovalError, tokenTransferredToContractError, userApprovalError } }, id, liquidity { addLiquiditySuccess, liquiditySetByPreLiquidityOpenTradingCall, lpTotalSupply, pairAddress, postLiquidityEnableTradingCall, postLiquidityEnableTradingSuccess, preLiquidityEnableTradingCall, preLiquidityEnableTradingSuccess, preLiquidityEnableTradingSupportsTransfer }, networkId, owner { ownerAddress, ownerEthBalance, ownerTokenBalance }, sortKey, status, swap { buyGasUsed, buySuccess, buyTax, maxBuyAmount, maxSellAmount, sellGasUsed, sellSuccess, sellTax }, timestamp, token { canRenounceOwnership, canTransferOwnership, contractAddress, decimals, isOwnerRenounced, tokenName, tokenSymbol, totalSupply }, transfer { tokenContractApprovalSuccess, tokenTransferredToContractSuccess, userApprovalSuccess }, uuid, uuidHashKey
  }
}`, vars, sink);
        });
        this.onDetailedStatsUpdated = (vars, sink) => __awaiter(this, void 0, void 0, function* () {
            return this.sdk.subscribe(`subscription OnDetailedStatsUpdated($pairId: String, $statsType: TokenPairStatisticsType, $tokenOfInterest: TokenOfInterest) {
  onDetailedStatsUpdated (pairId: $pairId, statsType: $statsType, tokenOfInterest: $tokenOfInterest) {
    bucketCount, pairId, queryTimestamp, statsType, stats_day1 { buckets { end, start }, buyVolume { buckets, change, currentValue, previousValue }, buyers { buckets, change, currentValue, previousValue }, buys { buckets, change, currentValue, previousValue }, endTimestamp, sellVolume { buckets, change, currentValue, previousValue }, sellers { buckets, change, currentValue, previousValue }, sells { buckets, change, currentValue, previousValue }, timestamp, traders { buckets, change, currentValue, previousValue }, transactions { buckets, change, currentValue, previousValue }, volume { buckets, change, currentValue, previousValue }, windowSize }, stats_hour1 { buckets { end, start }, buyVolume { buckets, change, currentValue, previousValue }, buyers { buckets, change, currentValue, previousValue }, buys { buckets, change, currentValue, previousValue }, endTimestamp, sellVolume { buckets, change, currentValue, previousValue }, sellers { buckets, change, currentValue, previousValue }, sells { buckets, change, currentValue, previousValue }, timestamp, traders { buckets, change, currentValue, previousValue }, transactions { buckets, change, currentValue, previousValue }, volume { buckets, change, currentValue, previousValue }, windowSize }, stats_hour4 { buckets { end, start }, buyVolume { buckets, change, currentValue, previousValue }, buyers { buckets, change, currentValue, previousValue }, buys { buckets, change, currentValue, previousValue }, endTimestamp, sellVolume { buckets, change, currentValue, previousValue }, sellers { buckets, change, currentValue, previousValue }, sells { buckets, change, currentValue, previousValue }, timestamp, traders { buckets, change, currentValue, previousValue }, transactions { buckets, change, currentValue, previousValue }, volume { buckets, change, currentValue, previousValue }, windowSize }, stats_hour12 { buckets { end, start }, buyVolume { buckets, change, currentValue, previousValue }, buyers { buckets, change, currentValue, previousValue }, buys { buckets, change, currentValue, previousValue }, endTimestamp, sellVolume { buckets, change, currentValue, previousValue }, sellers { buckets, change, currentValue, previousValue }, sells { buckets, change, currentValue, previousValue }, timestamp, traders { buckets, change, currentValue, previousValue }, transactions { buckets, change, currentValue, previousValue }, volume { buckets, change, currentValue, previousValue }, windowSize }, stats_min5 { buckets { end, start }, buyVolume { buckets, change, currentValue, previousValue }, buyers { buckets, change, currentValue, previousValue }, buys { buckets, change, currentValue, previousValue }, endTimestamp, sellVolume { buckets, change, currentValue, previousValue }, sellers { buckets, change, currentValue, previousValue }, sells { buckets, change, currentValue, previousValue }, timestamp, traders { buckets, change, currentValue, previousValue }, transactions { buckets, change, currentValue, previousValue }, volume { buckets, change, currentValue, previousValue }, windowSize }, tokenOfInterest
  }
}`, vars, sink);
        });
        this.onNftEventsCreated = (vars, sink) => __awaiter(this, void 0, void 0, function* () {
            return this.sdk.subscribe(`subscription OnNftEventsCreated($address: String, $networkId: Int) {
  onNftEventsCreated (address: $address, networkId: $networkId) {
    address, events { aggregatorAddress, blockNumber, contractAddress, eventType, exchangeAddress, fillSource, id, individualPriceNetworkBaseToken, individualPriceUsd, individualTradePrice, logIndex, maker, networkId, numberOfTokens, orderDirection, paymentTokenAddress, poolAddress, priceError, sortKey, taker, timestamp, tokenId, totalPriceNetworkBaseToken, totalPriceUsd, totalTradePrice, tradeOffer { ... on NftEventNftTradeItem { address, amount, recipient, tokenId, type }, ... on NftEventTokenTradeItem { address, amount, individualPriceNetworkBaseToken, individualPriceUsd, individualTradePrice, isPrice, priceError, recipient, totalPriceNetworkBaseToken, totalPriceUsd, totalTradePrice, type } }, tradeReceived { ... on NftEventNftTradeItem { address, amount, recipient, tokenId, type }, ... on NftEventTokenTradeItem { address, amount, individualPriceNetworkBaseToken, individualPriceUsd, individualTradePrice, isPrice, priceError, recipient, totalPriceNetworkBaseToken, totalPriceUsd, totalTradePrice, type } }, transactionHash, transactionIndex }, id, networkId
  }
}`, vars, sink);
        });
        this.onPricesUpdated = (vars, sink) => __awaiter(this, void 0, void 0, function* () {
            return this.sdk.subscribe(`subscription OnPricesUpdated($input: [OnPricesUpdatedInput!]!) {
  onPricesUpdated (input: $input) {
    address, confidence, networkId, poolAddress, priceUsd, timestamp
  }
}`, vars, sink);
        });
        this.onLatestTokens = (vars, sink) => __awaiter(this, void 0, void 0, function* () {
            return this.sdk.subscribe(`subscription OnLatestTokens($id: String, $networkId: Int, $tokenAddress: String) {
  onLatestTokens (id: $id, networkId: $networkId, tokenAddress: $tokenAddress) {
    blockHash, blockNumber, creatorAddress, creatorBalance, decimals, id, networkId, simulationResults { buyGasUsed, buySuccess, buyTax, canRenounceOwnership, canTransferOwnership, isOwnerRenounced, maxBuyAmount, maxSellAmount, openTradingCall, sellGasUsed, sellSuccess, sellTax }, timeCreated, tokenAddress, tokenName, tokenSymbol, totalSupply, traceIndex, transactionHash, transactionIndex
  }
}`, vars, sink);
        });
        this.onEventsCreated = (vars, sink) => __awaiter(this, void 0, void 0, function* () {
            return this.sdk.subscribe(`subscription OnEventsCreated($address: String, $id: String, $quoteToken: QuoteToken) {
  onEventsCreated (address: $address, id: $id, quoteToken: $quoteToken) {
    address, events { address, baseTokenPrice, blockHash, blockNumber, data { ... on BurnEventData { amount0, amount0Shifted, amount1, amount1Shifted, tickLower, tickUpper, type }, ... on MintEventData { amount0, amount0Shifted, amount1, amount1Shifted, tickLower, tickUpper, type }, ... on PoolBalanceChangedEventData { amount0, amount0Shifted, amount1, amount1Shifted, liquidity0, liquidity1, protocolFeeAmount0, protocolFeeAmount1, sender, token0, token1, type }, ... on SwapEventData { amount0, amount0In, amount0Out, amount1, amount1In, amount1Out, amountNonLiquidityToken, priceBaseToken, priceBaseTokenTotal, priceUsd, priceUsdTotal, tick, type } }, eventDisplayType, eventType, id, labels { sandwich { label, sandwichType, token0DrainedAmount, token1DrainedAmount }, washtrade { label } }, liquidityToken, logIndex, maker, networkId, quoteToken, timestamp, token0Address, token0PoolValueUsd, token0SwapValueUsd, token0ValueBase, token1Address, token1PoolValueUsd, token1SwapValueUsd, token1ValueBase, transactionHash, transactionIndex }, id, networkId, quoteToken
  }
}`, vars, sink);
        });
        this.onEventLabelCreated = (vars, sink) => __awaiter(this, void 0, void 0, function* () {
            return this.sdk.subscribe(`subscription OnEventLabelCreated($id: String) {
  onEventLabelCreated(id: $id) {
    data {
      ... on FrontRunLabelData {
        index
        token0DrainedAmount
        token1DrainedAmount
      }
      ... on SandwichedLabelData {
        token0DrainedAmountSandwich: token0DrainedAmount
        token1DrainedAmountSandwich: token1DrainedAmount
      }
    }
    id
    label
    logIndex
    networkId
    timestamp
    transactionHash
    transactionIndex
  }
}
`, vars, sink);
        });
        this.onNftPoolEventsCreated = (vars, sink) => __awaiter(this, void 0, void 0, function* () {
            return this.sdk.subscribe(`subscription OnNftPoolEventsCreated($collectionAddress: String, $exchangeAddress: String, $networkId: Int, $poolAddress: String) {
  onNftPoolEventsCreated (collectionAddress: $collectionAddress, exchangeAddress: $exchangeAddress, networkId: $networkId, poolAddress: $poolAddress) {
    collectionAddress, events { blockHash, blockNumber, collectionAddress, collectionId, data { ... on NewPoolEventData { assetRecipientAddress, bondingCurveAddress, bondingCurveType, buyPriceT, collectionAddress, createdAt, delta, feeAmountT, nbtRatio, networkId, nftTokenBalance, ownerAddress, poolAddress, sellPriceT, startPriceT, tokenAddress, tokenBalanceT, type, usdRatio }, ... on NewPoolEventDataV2 { assetRecipientAddress, bondingCurveAddress, bondingCurveType, buyPriceT, collectionAddress, createdAt, delta, feeAmountT, nbtRatio, networkId, nftAssets { address, attributes { class, css, displayType, maxValue, name, value, valueType }, description, id, media { image, processed, thumbLg, thumbSm }, name, networkId, originalImage, quantity, rawAssetData { animationUrl, externalUrl, imageData, imageUrl }, tokenId, uri }, nftTokenIds, nftTokenQuantities, ownerAddress, poolAddress, poolNftType, propertyChecker, royalties { percent, recipient }, sellPriceT, startPriceT, tokenAddress, tokenBalanceT, type, usdRatio }, ... on NftPoolAssetRecipientUpdateEventData { newAssetRecipient, type }, ... on NftPoolDeltaUpdateEventData { newDelta, type }, ... on NftPoolFeeUpdateEventData { nbtRatio, newFeeT, type, usdRatio }, ... on NftPoolNftDepositEventData { nftTokenBalance, nftTokenIds, tokenBalanceT, type }, ... on NftPoolNftDepositEventDataV2 { nftAssets { address, attributes { class, css, displayType, maxValue, name, value, valueType }, description, id, media { image, processed, thumbLg, thumbSm }, name, networkId, originalImage, quantity, rawAssetData { animationUrl, externalUrl, imageData, imageUrl }, tokenId, uri }, nftTokenAmounts, nftTokenIds, tokenBalanceT, type }, ... on NftPoolNftWithdrawalEventData { nftTokenBalance, nftTokenIds, tokenBalanceT, type }, ... on NftPoolNftWithdrawalEventDataV2 { nftAssets { address, attributes { class, css, displayType, maxValue, name, value, valueType }, description, id, media { image, processed, thumbLg, thumbSm }, name, networkId, originalImage, quantity, rawAssetData { animationUrl, externalUrl, imageData, imageUrl }, tokenId, uri }, nftTokenAmounts, nftTokenIds, tokenBalanceT, type }, ... on NftPoolOwnershipTransferredEventDataV2 { newOwner, type }, ... on NftPoolSpotPriceUpdateEventData { nbtRatio, newBuyPriceT, newSellPriceT, newSpotPriceT, type, usdRatio }, ... on NftPoolSpotPriceUpdateEventDataV2 { nbtRatio, newBuyPriceT, newSellPriceT, newSpotPriceT, type, usdRatio }, ... on NftPoolTokenDepositEventData { amountT, nbtRatio, nftTokenBalance, tokenBalanceT, type, usdRatio }, ... on NftPoolTokenDepositEventDataV2 { amountT, nbtRatio, tokenBalanceT, type, usdRatio }, ... on NftPoolTokenWithdrawalEventData { amountT, nbtRatio, nftTokenBalance, tokenBalanceT, type, usdRatio }, ... on NftPoolTokenWithdrawalEventDataV2 { amountT, nbtRatio, tokenBalanceT, type, usdRatio }, ... on SwapNftInPoolEventData { amountT, nbtRatio, newBuyPriceT, newDelta, newSellPriceT, newSpotPriceT, nftTokenBalance, nftsTransfered { amountT, nftTokenId }, poolFeeT, protocolFeeT, tokenBalanceT, tokenId, type, usdRatio }, ... on SwapNftInPoolEventDataV2 { amountT, nbtRatio, newBuyPriceT, newDelta, newSellPriceT, newSpotPriceT, nftAssets { address, attributes { class, css, displayType, maxValue, name, value, valueType }, description, id, media { image, processed, thumbLg, thumbSm }, name, networkId, originalImage, quantity, rawAssetData { animationUrl, externalUrl, imageData, imageUrl }, tokenId, uri }, nftsTransfered { amountT, nftQuantity, nftTokenId }, poolFeeT, protocolFeeT, tokenBalanceT, tokenId, type, usdRatio }, ... on SwapNftOutPoolEventData { amountT, nbtRatio, newBuyPriceT, newDelta, newSellPriceT, newSpotPriceT, nftTokenBalance, nftsTransfered { amountT, nftTokenId }, poolFeeT, protocolFeeT, tokenBalanceT, tokenId, type, usdRatio }, ... on SwapNftOutPoolEventDataV2 { amountT, nbtRatio, newBuyPriceT, newDelta, newSellPriceT, newSpotPriceT, nftAssets { address, attributes { class, css, displayType, maxValue, name, value, valueType }, description, id, media { image, processed, thumbLg, thumbSm }, name, networkId, originalImage, quantity, rawAssetData { animationUrl, externalUrl, imageData, imageUrl }, tokenId, uri }, nftsTransfered { amountT, nftQuantity, nftTokenId }, poolFeeT, protocolFeeT, tokenBalanceT, tokenId, type, usdRatio } }, eventType, exchangeAddress, id, logIndex, maker, networkId, poolAddress, poolType, timestamp, tokenAddress, transactionHash, transactionIndex }, exchangeAddress, id, networkId, poolAddress
  }
}`, vars, sink);
        });
        this.onBarsUpdated = (vars, sink) => __awaiter(this, void 0, void 0, function* () {
            return this.sdk.subscribe(`subscription OnBarsUpdated($pairId: String, $quoteToken: QuoteToken, $statsType: TokenPairStatisticsType) {
  onBarsUpdated (pairId: $pairId, quoteToken: $quoteToken, statsType: $statsType) {
    aggregates { r1 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r1D { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r1S { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r5 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r5S { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r7D { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r15 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r15S { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r30 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r30S { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r60 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r240 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r720 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } } }, eventSortKey, networkId, pairAddress, pairId, quoteToken, quoteTokenAddress, statsType, timestamp
  }
}`, vars, sink);
        });
    }
}
exports.Subscribe = Subscribe;
//# sourceMappingURL=Subscribe.js.map