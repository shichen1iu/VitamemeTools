"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseVariables = exports.getLeafArgs = exports.getLeafType = void 0;
const fs_1 = __importDefault(require("fs"));
const gql = __importStar(require("gql-query-builder"));
const mkdirp_1 = require("mkdirp");
const path_1 = __importDefault(require("path"));
function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
const getLeafType = (type, allTypes, result, currentName, level = 0) => {
    var _a, _b;
    if (level > 8 || !(type === null || type === void 0 ? void 0 : type.kind) || type.isDeprecated)
        return result;
    // If it's a scalar, return the name
    if (type.kind === "SCALAR" || type.kind === "ENUM")
        return [...result, currentName];
    if (type.kind === "UNION") {
        // Find all the possible types
        const possibleTypes = (_a = allTypes.find((t) => t.name === type.name)) === null || _a === void 0 ? void 0 : _a.possibleTypes;
        // For each of the possible types, treat it as a sub object with a set of fields
        const possibleTypeLeaves = possibleTypes === null || possibleTypes === void 0 ? void 0 : possibleTypes.map((f) => {
            const resolvedType = allTypes.find((t) => t.name === f.name);
            return (0, exports.getLeafType)(resolvedType, allTypes, [], `... on ${f.name}`, level + 1);
        }).flat();
        if (!(possibleTypeLeaves === null || possibleTypeLeaves === void 0 ? void 0 : possibleTypeLeaves.length)) {
            console.log("No possible types for union", type);
            throw new Error(`No possible types for union type ${currentName}`);
        }
        return [...result, ...[{ [currentName]: possibleTypeLeaves }]];
    }
    // If it's an object resolve it.
    if (type.kind === "OBJECT") {
        // For each of the fields of the subtype, resolve them
        const subType = allTypes.find((t) => t.name === type.name);
        const subTypeLeaves = ((_b = subType === null || subType === void 0 ? void 0 : subType.fields) !== null && _b !== void 0 ? _b : [])
            .filter((t) => !t.isDeprecated)
            .map((f) => (0, exports.getLeafType)(f.type, allTypes, [], f.name, level + 1))
            .flat();
        return [
            ...result,
            ...(level === 0 ? subTypeLeaves : [{ [currentName]: subTypeLeaves }]),
        ];
    }
    // If it's a list, resolve the first object type
    if (type.kind === "LIST")
        return (0, exports.getLeafType)(type.ofType, allTypes, [...result], currentName, level);
    // If it's required, resolve the first object type
    if (type.kind === "NON_NULL")
        return (0, exports.getLeafType)(type.ofType, allTypes, [...result], currentName, level);
    throw new Error(`Unknown type ${type.name} ${type.kind}`);
};
exports.getLeafType = getLeafType;
const getLeafArgs = (type, result) => {
    var _a;
    if (type.kind === "NON_NULL" &&
        ["INPUT_OBJECT", "SCALAR", "OBJECT", "ENUM"].includes((_a = type.ofType) === null || _a === void 0 ? void 0 : _a.kind))
        return Object.assign(Object.assign({}, result), { type: `${type.ofType.name}!` });
    // If it's a scalar, return the name
    if (type.kind === "SCALAR" ||
        type.kind === "OBJECT" ||
        type.kind === "ENUM" ||
        type.kind === "INPUT_OBJECT")
        return Object.assign(Object.assign({}, result), { type: type.name, value: null });
    // If it's a list, resolve the first object type
    if (type.kind === "LIST")
        return (0, exports.getLeafArgs)(type.ofType, Object.assign(Object.assign({}, result), { list: true }));
    // If it's required, resolve the first object type
    if (type.kind === "NON_NULL")
        return (0, exports.getLeafArgs)(type.ofType, Object.assign(Object.assign({}, result), { required: true }));
    throw new Error(`Unknown type ${type.name} ${type.kind}`);
};
exports.getLeafArgs = getLeafArgs;
function parseVariables(args) {
    const parsedVariables = args.reduce((acc, arg) => {
        return Object.assign(Object.assign({}, acc), { [arg.name]: (0, exports.getLeafArgs)(arg.type, {}) });
    }, {});
    return parsedVariables;
}
exports.parseVariables = parseVariables;
/**
 * Runs a query against the currently published graphql schema,
 * and generates a query ts file for query.
 */
function run() {
    return __awaiter(this, void 0, void 0, function* () {
        console.log("Generating...");
        // Fetch schema from remote
        const res = yield fetch(`https://graph.codex.io/schema/latest.json`, {
            method: "GET",
        });
        const schemaJson = yield res.json();
        const types = schemaJson.__schema.types;
        const mutationType = types.find((type) => type.name === "Mutation");
        const queryType = types.find((type) => type.name === "Query");
        const subscriptionType = types.find((type) => type.name === "Subscription");
        for (const field of mutationType.fields) {
            const args = field.args;
            const parsedVariables = parseVariables(args);
            const parsedFields = (0, exports.getLeafType)(field.type, types, [], "").filter(Boolean);
            const mutationBuilderObject = gql.mutation({
                operation: field.name,
                variables: Object.keys(parsedVariables).length
                    ? parsedVariables
                    : undefined,
                fields: parsedFields.length ? parsedFields : undefined,
            });
            console.log(`Writing mutation: ${field.name}.graphql`);
            const mutationsFolderPath = path_1.default.join(__dirname, "..", "resources", "generated_mutations");
            yield (0, mkdirp_1.mkdirp)(mutationsFolderPath);
            const overridePath = path_1.default.join(__dirname, "..", "resources", "mutations_override");
            const filename = `${capitalize(field.name)}.graphql`;
            const filePath = path_1.default.join(mutationsFolderPath, filename);
            // If we have an override, use it.
            if (fs_1.default.existsSync(path_1.default.join(overridePath, filename)))
                fs_1.default.copyFileSync(path_1.default.join(overridePath, filename), filePath);
            else
                fs_1.default.writeFileSync(filePath, `mutation ${capitalize(field.name)}${mutationBuilderObject.query
                    .toString()
                    .slice("mutation ".length)}`);
        }
        for (const field of subscriptionType.fields) {
            const args = field.args;
            const parsedVariables = parseVariables(args);
            const parsedFields = (0, exports.getLeafType)(field.type, types, [], "").filter(Boolean);
            const subscriptionBuilderObject = gql.subscription({
                operation: field.name,
                variables: Object.keys(parsedVariables).length
                    ? parsedVariables
                    : undefined,
                fields: parsedFields.length ? parsedFields : undefined,
            });
            console.log(`Writing subscription: ${field.name}.graphql`);
            const subscriptionsFolderPath = path_1.default.join(__dirname, "..", "resources", "generated_subscriptions");
            yield (0, mkdirp_1.mkdirp)(subscriptionsFolderPath);
            const overridePath = path_1.default.join(__dirname, "..", "resources", "subscriptions_override");
            const filename = `${capitalize(field.name)}.graphql`;
            const subPath = path_1.default.join(subscriptionsFolderPath, filename);
            // If we have an override, use it.
            if (fs_1.default.existsSync(path_1.default.join(overridePath, filename)))
                fs_1.default.copyFileSync(path_1.default.join(overridePath, filename), subPath);
            else
                fs_1.default.writeFileSync(subPath, `subscription ${capitalize(field.name)}${subscriptionBuilderObject.query
                    .toString()
                    .slice("subscription ".length)}`);
        }
        // Write queries
        for (const field of queryType.fields) {
            if (field.isDeprecated) {
                console.log("Skipping deprecated field", field.name);
                continue;
            }
            const args = field.args;
            const parsedVariables = parseVariables(args);
            const parsedFields = (0, exports.getLeafType)(field.type, types, [], "").filter(Boolean);
            const queryBuilderObject = gql.query({
                operation: field.name,
                variables: Object.keys(parsedVariables).length
                    ? parsedVariables
                    : undefined,
                fields: parsedFields.length ? parsedFields : undefined,
            });
            console.log(`Writing query: ${field.name}.graphql`);
            const queriesFolderPath = path_1.default.join(__dirname, "..", "resources", "generated_queries");
            yield (0, mkdirp_1.mkdirp)(queriesFolderPath);
            const overridePath = path_1.default.join(__dirname, "..", "resources", "queries_override");
            const queryFileName = `${capitalize(field.name)}.graphql`;
            const queryPath = path_1.default.join(queriesFolderPath, queryFileName);
            // If we have an override, use it.
            if (fs_1.default.existsSync(path_1.default.join(overridePath, queryFileName)))
                fs_1.default.copyFileSync(path_1.default.join(overridePath, queryFileName), queryPath);
            else
                fs_1.default.writeFileSync(queryPath, `query ${capitalize(field.name)}${queryBuilderObject.query
                    .toString()
                    .slice("query ".length)}`);
        }
    });
}
run().then(() => process.exit());
//# sourceMappingURL=generateGraphql.js.map