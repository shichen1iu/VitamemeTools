'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.is = is;
exports.isType = isType;
exports.validate = validate;
exports.shallowEqual = shallowEqual;
require('./definitions/init');

const { ALIAS_KEYS, NODE_FIELDS, BUILDER_KEYS } = require('./definitions');

const t = exports; // Maps all exports to t

/**
 * Registers `is[Type]` and `assert[Type]` generated functions for a given `type`.
 * Pass `skipAliasCheck` to force it to directly compare `node.type` with `type`.
 */

function registerType(type) {
  const key = `is${type}`;

  const _isType = t[key] !== undefined ? t[key] : t[key] = (node, opts) => t.is(type, node, opts);

  t[`assert${type}`] = (node, opts = {}) => {
    if (!_isType(node, opts)) {
      throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}`);
    }
  };
}

exports.ALIAS_KEYS = ALIAS_KEYS;
exports.NODE_FIELDS = NODE_FIELDS;
exports.BUILDER_KEYS = BUILDER_KEYS;

/**
 * Registers `is[Type]` and `assert[Type]` for all types.
 */

for (const type in t.NODE_FIELDS) {
  registerType(type);
}

/**
 * Flip `ALIAS_KEYS` for faster access in the reverse direction.
 */

const TYPES = exports.TYPES = [];

t.FLIPPED_ALIAS_KEYS = Object.keys(t.ALIAS_KEYS).reduce((acc, type) => {
  const aliasKeys = t.ALIAS_KEYS[type];

  aliasKeys.forEach(alias => {
    if (acc[alias] === undefined) {
      TYPES.push(alias); // Populate `TYPES` with FLIPPED_ALIAS_KEY(S)

      // Registers `is[Alias]` and `assert[Alias]` functions for all aliases.
      t[`${alias.toUpperCase()}_TYPES`] = acc[alias];
      registerType(alias);

      acc[alias] = [];
    }

    acc[alias].push(type);
  });

  return acc;
}, {});

/**
 * Returns whether `node` is of given `type`.
 *
 * For better performance, use this instead of `is[Type]` when `type` is unknown.
 * Optionally, pass `skipAliasCheck` to directly compare `node.type` with `type`.
 */

function is(type, node, opts) {
  if (node === null || typeof node !== 'object') {
    return false;
  }

  const matches = isType(node.kind, type);
  if (!matches) {
    return false;
  }

  if (typeof opts === 'undefined') {
    return true;
  } else {
    return t.shallowEqual(node, opts);
  }
}

/**
 * Test if a `nodeType` is a `targetType` or if `targetType` is an alias of `nodeType`.
 */

function isType(nodeType, targetType) {
  if (nodeType === targetType) {
    return true;
  }

  // This is a fast-path. If the test above failed, but an alias key is found, then the
  // targetType was a primary node type, so there's no need to check the aliases.
  if (t.ALIAS_KEYS[targetType]) {
    return false;
  }

  const aliases = t.FLIPPED_ALIAS_KEYS[targetType];
  if (aliases) {
    if (aliases[0] === nodeType) {
      return true;
    }

    for (const alias of aliases) {
      if (nodeType === alias) {
        return true;
      }
    }
  }

  return false;
}

/**
 * For each call of #defineType, the following expression evalutates and generates
 * a builder function that validates incoming arguments and returns a valid AST node.
 */

for (const type in t.BUILDER_KEYS) {
  const keys = t.BUILDER_KEYS[type];
  const fields = t.NODE_FIELDS[type];

  function builder(...args) {
    if (args.length > keys.length) {
      throw new Error(`t.${type}: Too many arguments passed. Received ${args.length} but can receive ` + `no more than ${keys.length}`);
    }

    const node = keys.reduce((node, key, i) => {
      node[key] = args[i] === undefined ? fields[key].default : args[i];
      return node;
    }, { kind: type });

    for (const key in node) {
      validate(node, key, node[key]);
    }

    return node;
  }

  t[type[0].toLowerCase() + type.slice(1)] = builder;
}

/**
 * Executes the field validators for a given node
 */

function validate(node, key, val) {
  if (node === null || typeof node !== 'object') {
    return;
  }

  const fields = t.NODE_FIELDS[node.kind];
  if (fields === undefined) {
    return;
  }

  const field = fields[key];
  if (field === undefined || field.validate === undefined) {
    return;
  }

  if (field.optional && (val === undefined || val === null)) {
    return;
  }

  field.validate(node, key, val);
}

/**
 * Test if an object is shallowly equal.
 */

function shallowEqual(actual, expected) {
  for (const key in expected) {
    if (expected.hasOwnProperty(key) && actual[key] !== expected[key]) {
      return false;
    }
  }

  return true;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJpcyIsImlzVHlwZSIsInZhbGlkYXRlIiwic2hhbGxvd0VxdWFsIiwicmVxdWlyZSIsIkFMSUFTX0tFWVMiLCJOT0RFX0ZJRUxEUyIsIkJVSUxERVJfS0VZUyIsInQiLCJleHBvcnRzIiwicmVnaXN0ZXJUeXBlIiwidHlwZSIsImtleSIsIl9pc1R5cGUiLCJ1bmRlZmluZWQiLCJub2RlIiwib3B0cyIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsIlRZUEVTIiwiRkxJUFBFRF9BTElBU19LRVlTIiwiT2JqZWN0Iiwia2V5cyIsInJlZHVjZSIsImFjYyIsImFsaWFzS2V5cyIsImZvckVhY2giLCJhbGlhcyIsInB1c2giLCJ0b1VwcGVyQ2FzZSIsIm1hdGNoZXMiLCJraW5kIiwibm9kZVR5cGUiLCJ0YXJnZXRUeXBlIiwiYWxpYXNlcyIsImZpZWxkcyIsImJ1aWxkZXIiLCJhcmdzIiwibGVuZ3RoIiwiaSIsImRlZmF1bHQiLCJ0b0xvd2VyQ2FzZSIsInNsaWNlIiwidmFsIiwiZmllbGQiLCJvcHRpb25hbCIsImFjdHVhbCIsImV4cGVjdGVkIiwiaGFzT3duUHJvcGVydHkiXSwibWFwcGluZ3MiOiI7Ozs7O1FBc0VnQkEsRSxHQUFBQSxFO1FBcUJBQyxNLEdBQUFBLE07UUFrRUFDLFEsR0FBQUEsUTtRQTBCQUMsWSxHQUFBQSxZO0FBckxoQkMsUUFBUSxvQkFBUjs7QUFFQSxNQUFNLEVBQUVDLFVBQUYsRUFBY0MsV0FBZCxFQUEyQkMsWUFBM0IsS0FBNENILFFBQVEsZUFBUixDQUFsRDs7QUFFQSxNQUFNSSxJQUFJQyxPQUFWLEMsQ0FBbUI7O0FBRW5COzs7OztBQUtBLFNBQVNDLFlBQVQsQ0FBc0JDLElBQXRCLEVBQW9DO0FBQ2xDLFFBQU1DLE1BQU8sS0FBSUQsSUFBSyxFQUF0Qjs7QUFFQSxRQUFNRSxVQUFVTCxFQUFFSSxHQUFGLE1BQVdFLFNBQVgsR0FDWk4sRUFBRUksR0FBRixDQURZLEdBRVpKLEVBQUVJLEdBQUYsSUFBUyxDQUFDRyxJQUFELEVBQU9DLElBQVAsS0FBZ0JSLEVBQUVSLEVBQUYsQ0FBS1csSUFBTCxFQUFXSSxJQUFYLEVBQWlCQyxJQUFqQixDQUY3Qjs7QUFJQVIsSUFBRyxTQUFRRyxJQUFLLEVBQWhCLElBQXFCLENBQUNJLElBQUQsRUFBT0MsT0FBTyxFQUFkLEtBQXFCO0FBQ3hDLFFBQUksQ0FBQ0gsUUFBUUUsSUFBUixFQUFjQyxJQUFkLENBQUwsRUFBMEI7QUFDeEIsWUFBTSxJQUFJQyxLQUFKLENBQVcsa0JBQWlCTixJQUFLLGlCQUFnQk8sS0FBS0MsU0FBTCxDQUFlSCxJQUFmLENBQXFCLEVBQXRFLENBQU47QUFDRDtBQUNGLEdBSkQ7QUFLRDs7UUFFUVgsVSxHQUFBQSxVO1FBQVlDLFcsR0FBQUEsVztRQUFhQyxZLEdBQUFBLFk7O0FBRWxDOzs7O0FBSUEsS0FBSyxNQUFNSSxJQUFYLElBQW1CSCxFQUFFRixXQUFyQixFQUFrQztBQUNoQ0ksZUFBYUMsSUFBYjtBQUNEOztBQUVEOzs7O0FBSU8sTUFBTVMsd0JBQVEsRUFBZDs7QUFFUFosRUFBRWEsa0JBQUYsR0FBdUJDLE9BQU9DLElBQVAsQ0FBWWYsRUFBRUgsVUFBZCxFQUEwQm1CLE1BQTFCLENBQWlDLENBQUNDLEdBQUQsRUFBTWQsSUFBTixLQUFlO0FBQ3JFLFFBQU1lLFlBQVlsQixFQUFFSCxVQUFGLENBQWFNLElBQWIsQ0FBbEI7O0FBRUFlLFlBQVVDLE9BQVYsQ0FBa0JDLFNBQVM7QUFDekIsUUFBSUgsSUFBSUcsS0FBSixNQUFlZCxTQUFuQixFQUE4QjtBQUM1Qk0sWUFBTVMsSUFBTixDQUFXRCxLQUFYLEVBRDRCLENBQ1Q7O0FBRW5CO0FBQ0FwQixRQUFHLEdBQUVvQixNQUFNRSxXQUFOLEVBQW9CLFFBQXpCLElBQW9DTCxJQUFJRyxLQUFKLENBQXBDO0FBQ0FsQixtQkFBYWtCLEtBQWI7O0FBRUFILFVBQUlHLEtBQUosSUFBYSxFQUFiO0FBQ0Q7O0FBRURILFFBQUlHLEtBQUosRUFBV0MsSUFBWCxDQUFnQmxCLElBQWhCO0FBQ0QsR0FaRDs7QUFjQSxTQUFPYyxHQUFQO0FBQ0QsQ0FsQnNCLEVBa0JwQixFQWxCb0IsQ0FBdkI7O0FBb0JBOzs7Ozs7O0FBT08sU0FBU3pCLEVBQVQsQ0FBWVcsSUFBWixFQUEwQkksSUFBMUIsRUFBd0NDLElBQXhDLEVBQWdFO0FBQ3JFLE1BQUlELFNBQVMsSUFBVCxJQUFpQixPQUFPQSxJQUFQLEtBQWdCLFFBQXJDLEVBQStDO0FBQzdDLFdBQU8sS0FBUDtBQUNEOztBQUVELFFBQU1nQixVQUFVOUIsT0FBT2MsS0FBS2lCLElBQVosRUFBa0JyQixJQUFsQixDQUFoQjtBQUNBLE1BQUksQ0FBQ29CLE9BQUwsRUFBYztBQUNaLFdBQU8sS0FBUDtBQUNEOztBQUVELE1BQUksT0FBT2YsSUFBUCxLQUFnQixXQUFwQixFQUFpQztBQUMvQixXQUFPLElBQVA7QUFDRCxHQUZELE1BRU87QUFDTCxXQUFPUixFQUFFTCxZQUFGLENBQWVZLElBQWYsRUFBcUJDLElBQXJCLENBQVA7QUFDRDtBQUNGOztBQUVEOzs7O0FBSU8sU0FBU2YsTUFBVCxDQUFnQmdDLFFBQWhCLEVBQWtDQyxVQUFsQyxFQUErRDtBQUNwRSxNQUFJRCxhQUFhQyxVQUFqQixFQUE2QjtBQUMzQixXQUFPLElBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsTUFBSTFCLEVBQUVILFVBQUYsQ0FBYTZCLFVBQWIsQ0FBSixFQUE4QjtBQUM1QixXQUFPLEtBQVA7QUFDRDs7QUFFRCxRQUFNQyxVQUEwQjNCLEVBQUVhLGtCQUFGLENBQXFCYSxVQUFyQixDQUFoQztBQUNBLE1BQUlDLE9BQUosRUFBYTtBQUNYLFFBQUlBLFFBQVEsQ0FBUixNQUFlRixRQUFuQixFQUE2QjtBQUMzQixhQUFPLElBQVA7QUFDRDs7QUFFRCxTQUFLLE1BQU1MLEtBQVgsSUFBb0JPLE9BQXBCLEVBQTZCO0FBQzNCLFVBQUlGLGFBQWFMLEtBQWpCLEVBQXdCO0FBQ3RCLGVBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFPLEtBQVA7QUFDRDs7QUFFRDs7Ozs7QUFLQSxLQUFLLE1BQU1qQixJQUFYLElBQW1CSCxFQUFFRCxZQUFyQixFQUFtQztBQUNqQyxRQUFNZ0IsT0FBT2YsRUFBRUQsWUFBRixDQUFlSSxJQUFmLENBQWI7QUFDQSxRQUFNeUIsU0FBUzVCLEVBQUVGLFdBQUYsQ0FBY0ssSUFBZCxDQUFmOztBQUVBLFdBQVMwQixPQUFULENBQWlCLEdBQUdDLElBQXBCLEVBQTBCO0FBQ3hCLFFBQUlBLEtBQUtDLE1BQUwsR0FBY2hCLEtBQUtnQixNQUF2QixFQUErQjtBQUM3QixZQUFNLElBQUl0QixLQUFKLENBQ0gsS0FBSU4sSUFBSyx5Q0FBd0MyQixLQUFLQyxNQUFPLG1CQUE5RCxHQUNHLGdCQUFlaEIsS0FBS2dCLE1BQU8sRUFGMUIsQ0FBTjtBQUlEOztBQUVELFVBQU14QixPQUFPUSxLQUFLQyxNQUFMLENBQ1gsQ0FBQ1QsSUFBRCxFQUFPSCxHQUFQLEVBQVk0QixDQUFaLEtBQWtCO0FBQ2hCekIsV0FBS0gsR0FBTCxJQUFhMEIsS0FBS0UsQ0FBTCxNQUFZMUIsU0FBWixHQUF3QnNCLE9BQU94QixHQUFQLEVBQVk2QixPQUFwQyxHQUE4Q0gsS0FBS0UsQ0FBTCxDQUEzRDtBQUNBLGFBQU96QixJQUFQO0FBQ0QsS0FKVSxFQUtYLEVBQUVpQixNQUFNckIsSUFBUixFQUxXLENBQWI7O0FBUUEsU0FBSyxNQUFNQyxHQUFYLElBQWtCRyxJQUFsQixFQUF3QjtBQUN0QmIsZUFBU2EsSUFBVCxFQUFlSCxHQUFmLEVBQW9CRyxLQUFLSCxHQUFMLENBQXBCO0FBQ0Q7O0FBRUQsV0FBT0csSUFBUDtBQUNEOztBQUVEUCxJQUFFRyxLQUFLLENBQUwsRUFBUStCLFdBQVIsS0FBd0IvQixLQUFLZ0MsS0FBTCxDQUFXLENBQVgsQ0FBMUIsSUFBMkNOLE9BQTNDO0FBQ0Q7O0FBRUQ7Ozs7QUFJTyxTQUFTbkMsUUFBVCxDQUFrQmEsSUFBbEIsRUFBaUNILEdBQWpDLEVBQThDZ0MsR0FBOUMsRUFBd0Q7QUFDN0QsTUFBSTdCLFNBQVMsSUFBVCxJQUFpQixPQUFPQSxJQUFQLEtBQWdCLFFBQXJDLEVBQStDO0FBQzdDO0FBQ0Q7O0FBRUQsUUFBTXFCLFNBQVM1QixFQUFFRixXQUFGLENBQWNTLEtBQUtpQixJQUFuQixDQUFmO0FBQ0EsTUFBSUksV0FBV3RCLFNBQWYsRUFBMEI7QUFDeEI7QUFDRDs7QUFFRCxRQUFNK0IsUUFBUVQsT0FBT3hCLEdBQVAsQ0FBZDtBQUNBLE1BQUlpQyxVQUFVL0IsU0FBVixJQUF1QitCLE1BQU0zQyxRQUFOLEtBQW1CWSxTQUE5QyxFQUF5RDtBQUN2RDtBQUNEOztBQUVELE1BQUkrQixNQUFNQyxRQUFOLEtBQW1CRixRQUFROUIsU0FBUixJQUFxQjhCLFFBQVEsSUFBaEQsQ0FBSixFQUEyRDtBQUN6RDtBQUNEOztBQUVEQyxRQUFNM0MsUUFBTixDQUFlYSxJQUFmLEVBQXFCSCxHQUFyQixFQUEwQmdDLEdBQTFCO0FBQ0Q7O0FBRUQ7Ozs7QUFJTyxTQUFTekMsWUFBVCxDQUFzQjRDLE1BQXRCLEVBQXNDQyxRQUF0QyxFQUFpRTtBQUN0RSxPQUFLLE1BQU1wQyxHQUFYLElBQWtCb0MsUUFBbEIsRUFBNEI7QUFDMUIsUUFBSUEsU0FBU0MsY0FBVCxDQUF3QnJDLEdBQXhCLEtBQWdDbUMsT0FBT25DLEdBQVAsTUFBZ0JvQyxTQUFTcEMsR0FBVCxDQUFwRCxFQUFtRTtBQUNqRSxhQUFPLEtBQVA7QUFDRDtBQUNGOztBQUVELFNBQU8sSUFBUDtBQUNEIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcblxucmVxdWlyZSgnLi9kZWZpbml0aW9ucy9pbml0Jyk7XG5cbmNvbnN0IHsgQUxJQVNfS0VZUywgTk9ERV9GSUVMRFMsIEJVSUxERVJfS0VZUyB9ID0gcmVxdWlyZSgnLi9kZWZpbml0aW9ucycpO1xuXG5jb25zdCB0ID0gZXhwb3J0czsgLy8gTWFwcyBhbGwgZXhwb3J0cyB0byB0XG5cbi8qKlxuICogUmVnaXN0ZXJzIGBpc1tUeXBlXWAgYW5kIGBhc3NlcnRbVHlwZV1gIGdlbmVyYXRlZCBmdW5jdGlvbnMgZm9yIGEgZ2l2ZW4gYHR5cGVgLlxuICogUGFzcyBgc2tpcEFsaWFzQ2hlY2tgIHRvIGZvcmNlIGl0IHRvIGRpcmVjdGx5IGNvbXBhcmUgYG5vZGUudHlwZWAgd2l0aCBgdHlwZWAuXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXJUeXBlKHR5cGU6IHN0cmluZykge1xuICBjb25zdCBrZXkgPSBgaXMke3R5cGV9YDtcblxuICBjb25zdCBfaXNUeXBlID0gdFtrZXldICE9PSB1bmRlZmluZWRcbiAgICA/IHRba2V5XVxuICAgIDogdFtrZXldID0gKG5vZGUsIG9wdHMpID0+IHQuaXModHlwZSwgbm9kZSwgb3B0cyk7XG5cbiAgdFtgYXNzZXJ0JHt0eXBlfWBdID0gKG5vZGUsIG9wdHMgPSB7fSkgPT4ge1xuICAgIGlmICghX2lzVHlwZShub2RlLCBvcHRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB0eXBlIFwiJHt0eXBlfVwiIHdpdGggb3B0aW9uICR7SlNPTi5zdHJpbmdpZnkob3B0cyl9YCk7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgeyBBTElBU19LRVlTLCBOT0RFX0ZJRUxEUywgQlVJTERFUl9LRVlTIH07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGBpc1tUeXBlXWAgYW5kIGBhc3NlcnRbVHlwZV1gIGZvciBhbGwgdHlwZXMuXG4gKi9cblxuZm9yIChjb25zdCB0eXBlIGluIHQuTk9ERV9GSUVMRFMpIHtcbiAgcmVnaXN0ZXJUeXBlKHR5cGUpO1xufVxuXG4vKipcbiAqIEZsaXAgYEFMSUFTX0tFWVNgIGZvciBmYXN0ZXIgYWNjZXNzIGluIHRoZSByZXZlcnNlIGRpcmVjdGlvbi5cbiAqL1xuXG5leHBvcnQgY29uc3QgVFlQRVMgPSBbXTtcblxudC5GTElQUEVEX0FMSUFTX0tFWVMgPSBPYmplY3Qua2V5cyh0LkFMSUFTX0tFWVMpLnJlZHVjZSgoYWNjLCB0eXBlKSA9PiB7XG4gIGNvbnN0IGFsaWFzS2V5cyA9IHQuQUxJQVNfS0VZU1t0eXBlXTtcblxuICBhbGlhc0tleXMuZm9yRWFjaChhbGlhcyA9PiB7XG4gICAgaWYgKGFjY1thbGlhc10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgVFlQRVMucHVzaChhbGlhcyk7IC8vIFBvcHVsYXRlIGBUWVBFU2Agd2l0aCBGTElQUEVEX0FMSUFTX0tFWShTKVxuXG4gICAgICAvLyBSZWdpc3RlcnMgYGlzW0FsaWFzXWAgYW5kIGBhc3NlcnRbQWxpYXNdYCBmdW5jdGlvbnMgZm9yIGFsbCBhbGlhc2VzLlxuICAgICAgdFtgJHthbGlhcy50b1VwcGVyQ2FzZSgpfV9UWVBFU2BdID0gYWNjW2FsaWFzXTtcbiAgICAgIHJlZ2lzdGVyVHlwZShhbGlhcyk7XG5cbiAgICAgIGFjY1thbGlhc10gPSBbXTtcbiAgICB9XG5cbiAgICBhY2NbYWxpYXNdLnB1c2godHlwZSk7XG4gIH0pO1xuXG4gIHJldHVybiBhY2M7XG59LCB7fSk7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIGBub2RlYCBpcyBvZiBnaXZlbiBgdHlwZWAuXG4gKlxuICogRm9yIGJldHRlciBwZXJmb3JtYW5jZSwgdXNlIHRoaXMgaW5zdGVhZCBvZiBgaXNbVHlwZV1gIHdoZW4gYHR5cGVgIGlzIHVua25vd24uXG4gKiBPcHRpb25hbGx5LCBwYXNzIGBza2lwQWxpYXNDaGVja2AgdG8gZGlyZWN0bHkgY29tcGFyZSBgbm9kZS50eXBlYCB3aXRoIGB0eXBlYC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXModHlwZTogc3RyaW5nLCBub2RlOiBPYmplY3QsIG9wdHM/OiBPYmplY3QpOiBib29sZWFuIHtcbiAgaWYgKG5vZGUgPT09IG51bGwgfHwgdHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgbWF0Y2hlcyA9IGlzVHlwZShub2RlLmtpbmQsIHR5cGUpO1xuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHQuc2hhbGxvd0VxdWFsKG5vZGUsIG9wdHMpO1xuICB9XG59XG5cbi8qKlxuICogVGVzdCBpZiBhIGBub2RlVHlwZWAgaXMgYSBgdGFyZ2V0VHlwZWAgb3IgaWYgYHRhcmdldFR5cGVgIGlzIGFuIGFsaWFzIG9mIGBub2RlVHlwZWAuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVHlwZShub2RlVHlwZTogc3RyaW5nLCB0YXJnZXRUeXBlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKG5vZGVUeXBlID09PSB0YXJnZXRUeXBlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBUaGlzIGlzIGEgZmFzdC1wYXRoLiBJZiB0aGUgdGVzdCBhYm92ZSBmYWlsZWQsIGJ1dCBhbiBhbGlhcyBrZXkgaXMgZm91bmQsIHRoZW4gdGhlXG4gIC8vIHRhcmdldFR5cGUgd2FzIGEgcHJpbWFyeSBub2RlIHR5cGUsIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayB0aGUgYWxpYXNlcy5cbiAgaWYgKHQuQUxJQVNfS0VZU1t0YXJnZXRUeXBlXSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGFsaWFzZXM6ID9BcnJheTxzdHJpbmc+ID0gdC5GTElQUEVEX0FMSUFTX0tFWVNbdGFyZ2V0VHlwZV07XG4gIGlmIChhbGlhc2VzKSB7XG4gICAgaWYgKGFsaWFzZXNbMF0gPT09IG5vZGVUeXBlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIGFsaWFzZXMpIHtcbiAgICAgIGlmIChub2RlVHlwZSA9PT0gYWxpYXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEZvciBlYWNoIGNhbGwgb2YgI2RlZmluZVR5cGUsIHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbiBldmFsdXRhdGVzIGFuZCBnZW5lcmF0ZXNcbiAqIGEgYnVpbGRlciBmdW5jdGlvbiB0aGF0IHZhbGlkYXRlcyBpbmNvbWluZyBhcmd1bWVudHMgYW5kIHJldHVybnMgYSB2YWxpZCBBU1Qgbm9kZS5cbiAqL1xuXG5mb3IgKGNvbnN0IHR5cGUgaW4gdC5CVUlMREVSX0tFWVMpIHtcbiAgY29uc3Qga2V5cyA9IHQuQlVJTERFUl9LRVlTW3R5cGVdO1xuICBjb25zdCBmaWVsZHMgPSB0Lk5PREVfRklFTERTW3R5cGVdO1xuXG4gIGZ1bmN0aW9uIGJ1aWxkZXIoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IGtleXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGB0LiR7dHlwZX06IFRvbyBtYW55IGFyZ3VtZW50cyBwYXNzZWQuIFJlY2VpdmVkICR7YXJncy5sZW5ndGh9IGJ1dCBjYW4gcmVjZWl2ZSBgICtcbiAgICAgICAgICBgbm8gbW9yZSB0aGFuICR7a2V5cy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlID0ga2V5cy5yZWR1Y2UoXG4gICAgICAobm9kZSwga2V5LCBpKSA9PiB7XG4gICAgICAgIG5vZGVba2V5XSA9IChhcmdzW2ldID09PSB1bmRlZmluZWQgPyBmaWVsZHNba2V5XS5kZWZhdWx0IDogYXJnc1tpXSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSxcbiAgICAgIHsga2luZDogdHlwZSB9XG4gICAgKTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIG5vZGUpIHtcbiAgICAgIHZhbGlkYXRlKG5vZGUsIGtleSwgbm9kZVtrZXldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHRbdHlwZVswXS50b0xvd2VyQ2FzZSgpICsgdHlwZS5zbGljZSgxKV0gPSBidWlsZGVyO1xufVxuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBmaWVsZCB2YWxpZGF0b3JzIGZvciBhIGdpdmVuIG5vZGVcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUobm9kZT86IE9iamVjdCwga2V5OiBzdHJpbmcsIHZhbDogYW55KSB7XG4gIGlmIChub2RlID09PSBudWxsIHx8IHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGZpZWxkcyA9IHQuTk9ERV9GSUVMRFNbbm9kZS5raW5kXTtcbiAgaWYgKGZpZWxkcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZmllbGQgPSBmaWVsZHNba2V5XTtcbiAgaWYgKGZpZWxkID09PSB1bmRlZmluZWQgfHwgZmllbGQudmFsaWRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChmaWVsZC5vcHRpb25hbCAmJiAodmFsID09PSB1bmRlZmluZWQgfHwgdmFsID09PSBudWxsKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZpZWxkLnZhbGlkYXRlKG5vZGUsIGtleSwgdmFsKTtcbn1cblxuLyoqXG4gKiBUZXN0IGlmIGFuIG9iamVjdCBpcyBzaGFsbG93bHkgZXF1YWwuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChhY3R1YWw6IE9iamVjdCwgZXhwZWN0ZWQ6IE9iamVjdCk6IGJvb2xlYW4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBleHBlY3RlZCkge1xuICAgIGlmIChleHBlY3RlZC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGFjdHVhbFtrZXldICE9PSBleHBlY3RlZFtrZXldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4iXX0=